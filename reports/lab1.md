## 编程作业
编程作业中主要做了以下的工作：

1. 为`Task_Manager`添加了相应方法的实现，包括设置和获取各种信息
2. 在`TaskControlBlock`中添加了运行时间和系统调用统计的字段
3. 在`syscall`中调用系统调用之前进行系统调用的记录
4. 完成`sys_task_info`系统调用

针对栈溢出问题，在`entry.asm`中开辟更大的空间进行了解决。

## 问答作业
### 1 
使用的RustSBI版本：0.3.0-alpha.2    
程序出错行为：   
```bash
[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x80400414, kernel killed it.
[kernel] IllegalInstruction in application, kernel killed it.
[kernel] IllegalInstruction in application, kernel killed it.
```
### 2
1. 
刚进入 `__restore`时，a0 是上一个函数的返回，这里其实就是上下文的首地址（在栈中）。   

这里我觉得其实就一种使用场景，即从特权态恢复上下文，这里拆分出两个场景应该是系统调用，和进程切换的恢复。

2. 
从栈中取出三个保存上下文的寄存器（sstatus，sepc和sscratch)，并将他们重新写入到寄存器内。 

sstatus 寄存器标志了CPU的特权级。   
sepc标志了Trap结束后的下一条指令地址。   
sscratch 指向应用的内核栈栈顶。    

我们需要这些寄存器才能让处理器正确回到用户态的特权级，执行位置和该应用的内核栈栈顶。   

3. 
根据介绍，x2 作为 sp 寄存器指向栈地址，而我们在交换 sscratch 和 sp 的时候就已经算间接保存了。

x4 的原因是根本用不到吧，因为是线程指针，可能恒为0就ok

4. 
sp 指针和 sscrath 指针内容进行调换，后续我们将要使用内核栈，因此 sp 指向我们会使用的内核栈。而 sscrath 负责保存 sp 指针内容。

5. 
sret，会返回到用户态的程序内容继续执行。（在之前已经从内核栈中将本来的 CSR 寄存器状态进行了还原）

6. 
和4其实是类似的操作，主要考虑是现在我们要使用哪个栈，是内核栈还是用户栈，而 sp 需要指向我们使用的栈。

7. 通过 sbi 调用 ecall 时，会进入 stvec 寄存器记录的 Trap 地址开始执行。


## 荣誉准则
在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

> 在微信群中找到了针对`get_time()`为0的问题，发现是栈溢出的原因，并进行了解决。

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

> 《[rCore-Tutorial-Book-v3](http://rcore-os.cn/rCore-Tutorial-Book-v3/)》

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

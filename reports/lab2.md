## 编程作业
编程作业中主要做了以下的工作：

1. 针对 `sys_get_time` 和 `sys_task_info` 两个系统调用，首先利用`translated_byte_buffer` 让内核访问应用地址空间的特定区域，然后进行类型转换并赋值，完成工作。

核心代码如下
```rust 
let mut timeval = translated_byte_buffer(
        current_user_token(),
        ts as *const u8,
        core::mem::size_of::<TimeVal>(),
    );
    let ts: *mut TimeVal = timeval[0].as_mut_ptr().cast();
```

2. 对于 `mmap` 和 `munmap`，插入一个段，进行映射这里我们在页表中设置 `map` 和 `unmap` 方法。对于 `munmap` 我们多设置了一个检验过程，确保 unmap 的部分都是已经被映射的。

核心代码如下
```rust
process.rs
for vpn in vpn_range {
            if !vaddr_mapped(current_user_token(), vpn) {
                return -1;
            }
        }


memory_set.rs
pub fn unmap(&mut self, vpn_range: VPNRange) {
        for vpn in vpn_range {
            self.page_table.unmap(vpn);
        }
    }
```
## 问答作业
1. 
各种标志位可以用来判断页面是否合法以及页面的访问控制和访问情况。前者可以保证地址空间的隔离和应用访问限制。后者则与页面替换，页是否需要写入相关（比如缓存时脏了需要写回）

2. 
- 没有创建虚拟页到物理页的映射时会发生，比如栈溢出。其他比如fork系统调用也会出现缺页异常。
- 发生缺页时最重要的就是 `satp` 寄存器。
- 2^25，应该是以M计数的数量
- `Lazy` 可以使用页表的标志位进行标记，在异常时可以根据标志位考虑是否分配。也可以通过维护一个虚拟页表的数据结构。

3.  略


## 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
> 无
2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
> 《rcore》

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
